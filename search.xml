<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring</title>
    <url>/2022/09/03/Spring/</url>
    <content><![CDATA[<p>ArrayList:</p>
<p>底层通过数组实现</p>
<p>初始容量：10</p>
<p>扩容  1.5倍</p>
<p>LinkedList 双向链表</p>
<p>hashMap</p>
<p>初始容量：16</p>
<p>最大容量： 2<sup>30</sup></p>
<p>默认加载因子：0.75</p>
<p>转换成树的阈值：8</p>
<p>取消树的阈值：6</p>
<p>对容器进行树化的最小容量：64</p>
<p>《<em>代码大全2</em>》</p>
<p>《<em>黑客与画家</em>》</p>
<p>《<em>万历十五年</em>》</p>
<p>全球通史</p>
<p>浮生六记</p>
<p>白夜行</p>
<p>百年孤独</p>
<p>少年得到</p>
<p>java7</p>
<p>默认容量是16 必须是2的幂次方，不是的话向上调整为2的幂</p>
<p>-为什么2的幂</p>
<p>  hash &amp;( length-1 ) </p>
<p>length-1 二进制全为1 进行按位与，快速拿到数组的下标</p>
<p>负载因子0.75</p>
<ul>
<li>时间和空间提供的折中</li>
</ul>
<p>当数据到达容量*负载因子的时候，扩容一倍</p>
<p>允许传入key 为null 的值，放在第0位</p>
<p><strong>get()方法</strong></p>
<p>首先通过key 取hash,取hash用的是 hash(k)&amp;(length-1), 得到桶的位置，在遍历冲突链，判断key是否相等返回value值 </p>
<p><strong>put()方法</strong></p>
<p>将对应的key 和value 放到map里，会做一次查找，看是否包含该元组，如果找到直接返回，找不到，则插入新的entry,插入的方式是头插法。</p>
<p>先扩容再插入元素</p>
<p><strong>remove()方法</strong></p>
<p>删除key对应的entry，找到key,删除</p>
<p>java8 的改进</p>
<p>数组+链表+红黑树</p>
<p>当链表的元素到达8个时，会将链表转换为红黑树，在这些位置进行查找时可以降低时间复杂度为O(logN)。</p>
<p>put()</p>
<p>第一次put 的时候会触发resize 操作进行初始化数组长度</p>
<p>找到具体的数组下标，如果此位置没有值，那么直接初始化一个node,并放在这个位置</p>
<p>如果有数据，首先判断该位置的第一个数据和我们要插入的数据，key 是不是相等，如果是，覆盖value，并取出返回这个节点旧值，</p>
<p>如果这个节点是红黑树的节点，调用红黑树的插入方法，如果不是，则为链表，插入到链表的最后面如果插入的是链表中的第8个，会触发转红黑树的操作</p>
<p>如果插入的值导致了size 超过了阈值，触发扩容操作。每次扩容容量为原来的2倍，并进行数据迁移<br>： 将数组扩大一倍，将阈值扩大一倍 ，遍历数组，进行数据迁移</p>
<p>get()</p>
<p>计算key的hash值找到数组下标</p>
<p>判断数组该位置的key 是不是刚好是要找的值，如果不是</p>
<p>判断元素类型是否为TreeNode,如果是，用红黑树的方法读取数据，如果不是</p>
<p>遍历链表，直到找到相等的key,返回value</p>
<p>concurrentHashMap:</p>
<p> 1.7 </p>
<p>采用分段锁技术，默认情况下将数组分成16个段， 每个段内的结构类似于hashMap,有数组和链表组成</p>
<p>put()</p>
<p>再进行put 操作的过程中，通过key 的hash值来确定具体的桶位置，如果这个桶没有初始化，则用第0个segment的数据进行初始化，</p>
<p>存储值的时候，首先要对这个segment进行加锁，如果被其他线程获得，则调用scanAndLockForPut()自旋获直到获取锁为止，然后通过 hash&amp;(length-1)找到具体的数组下标，没有元素，则放入该键值对，有值就进行遍历，看有没有相同的key,覆盖value 返回旧值，没有相同key 的时候，先判断需不需要进行扩容，扩容后插入该值，不需要则插到头节点，然后释放锁</p>
<p>1.8</p>
<p>采用 数组+链表+红黑树的方式实现，加锁采用的是CAS+synchronized实现</p>
<p>put()</p>
<ol>
<li>传入一个不为空的键值对，如果为空就直接报错了。hashMap 是可以为空的</li>
</ol>
<ul>
<li><p>基于并发考虑，hashMap 在get 到空值的时候，可以通过contains(key )来判断是否包这个key</p>
<p>  而并发的map,在get(key)时候得null 值，不能判断是映射的value是null,还是没有找到对应的key,</p>
<p>  并发环境下contains(key)不靠谱</p>
</li>
</ul>
<ol start="2">
<li>接着判断table是否为空，如果为空就进入初始化阶段       </li>
<li>如果判断数组中某个指定的桶式空的，那就直接把键值对插入到桶中作为头节点，这个操作没锁</li>
<li>如果要插入的桶中的hash 值为-1，也就是MOVED 状态，那就说明有线程正在进行扩容操作，那么当前线程就进入协助扩容阶段</li>
<li>需要把数据插入到链表或者树中，如果这个节点是一个链表节点，那么就遍历这个链表，如果发现有相同的key值就更新value,如果遍历完了都没有发现相同的key,就需要在链表的尾部插入该数据，插入结束后判断该链表节点个数是否大于8，并且size&gt;=64就进行树化，否则只进行扩容操作</li>
<li>如果这个节点是一个红黑树的节点，那就需要按照树的插入规则进行插入。</li>
<li>put结束后，需要给map 已存储的数量+1，在addCount方法中判断是否需要扩容</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">//hash值   </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="comment">//记录相应链表的长度   </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//无限循环状态</span></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//tab如果为空就进行初始化</span></span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">               tab = initTable();</span><br><span class="line">          </span><br><span class="line">           <span class="comment">//找到hash值对应的数组下标，得到第一个节点f</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">//如果数组位置为空，用一次cas操作将这个新值放入其中即可，这个put</span></span><br><span class="line">               <span class="comment">//如果cas失败，那就是有并发操作，进到下一个循环就好了。</span></span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，</span></span><br><span class="line">           <span class="comment">// 不过从名字上也能猜到，肯定是因为在扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="comment">//====================================================</span></span><br><span class="line">           <span class="comment">// 走到这说明 这个位置不空</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//获取头节点的监视器锁</span></span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   </span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       <span class="comment">//------------------------</span></span><br><span class="line">                       <span class="comment">//头节点的hash大于0 说明式链表</span></span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">//链表的长度</span></span><br><span class="line">                           binCount = <span class="number">1</span>;</span><br><span class="line">                           <span class="comment">//遍历链表</span></span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               <span class="comment">//如果发现了相等的key,覆盖value，返回旧value</span></span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="comment">//不相等且遍历到了最后，则插入链表的末端</span></span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                   pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, <span class="literal">null</span>);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">//---------------------------------------</span></span><br><span class="line">                       <span class="comment">//如果是红黑树</span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                           <span class="comment">//调用红黑树的方法插入新节点</span></span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">//如果链表的长度大于阈值，树化</span></span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       <span class="comment">//如果长度小于64 是不会进行树化的，只能进行扩容操作</span></span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>get()</p>
<p>通过key 的hash,找到key所在的数组下标，如果不为空并且头节点就是要找的值，直接返回该值</p>
<p>如果 hash&lt;0 则调用node的find方法找到与key 相同的节点,找不到返回null</p>
<p>如果不是，则调用链表的查找方法，找到该值。找不到返回null,</p>
<p>Synchronized</p>
<p>同一时刻，最多只有一个线程执行该段代码，以达到保证并发安全的效果</p>
]]></content>
      <categories>
        <category>Spring 系列</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 教程</title>
    <url>/2022/08/27/hexo_learning/</url>
    <content><![CDATA[<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="创建一个新文章-md-文件"><a href="#创建一个新文章-md-文件" class="headerlink" title="创建一个新文章 .md 文件"></a>创建一个新文章 .md 文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="将md-生成静态文件"><a href="#将md-生成静态文件" class="headerlink" title="将md 生成静态文件"></a>将md 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="启动本地服务器查看"><a href="#启动本地服务器查看" class="headerlink" title="启动本地服务器查看"></a>启动本地服务器查看</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="无误后将文章发布到GitHub"><a href="#无误后将文章发布到GitHub" class="headerlink" title="无误后将文章发布到GitHub"></a>无误后将文章发布到GitHub</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="引用自己写的别的文章"><a href="#引用自己写的别的文章" class="headerlink" title="引用自己写的别的文章"></a>引用自己写的别的文章</h3><p>有两种方式：<br>1、通过模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link md的名字  显示的名字%&#125;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">&#123;% post_link markdown markdown %&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<a href="/2020/09/11/markdown/" title="markdown">markdown</a>

<p>2、引用永久链接： hexo 生成的文章是 /年/月/日/文件 格式，所以markdown引用链接就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[排序模板](/2020/09/11/markdown)</span><br></pre></td></tr></table></figure>
<p>效果：<br><a href="/2020/09/11/markdown">排序模板</a></p>
]]></content>
      <categories>
        <category>hexo 教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>gitLearn</title>
    <url>/2020/09/12/gitLearn/</url>
    <content><![CDATA[<h3 id="安装完git"><a href="#安装完git" class="headerlink" title="安装完git:"></a>安装完git:</h3><h4 id="1-每个机器都必须自报家门：你的名字和Email地址"><a href="#1-每个机器都必须自报家门：你的名字和Email地址" class="headerlink" title="1. 每个机器都必须自报家门：你的名字和Email地址"></a>1. 每个机器都必须自报家门：你的名字和Email地址</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p><code> --global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置.</p>
<span id="more"></span>
<h4 id="2-新建文件夹，交给git-托管"><a href="#2-新建文件夹，交给git-托管" class="headerlink" title="2. 新建文件夹，交给git 托管"></a>2. 新建文件夹，交给git 托管</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<h4 id="3-新建readme-txt做完工作后添加修改的文件到仓库暂存区"><a href="#3-新建readme-txt做完工作后添加修改的文件到仓库暂存区" class="headerlink" title="3. 新建readme.txt做完工作后添加修改的文件到仓库暂存区"></a>3. 新建readme.txt做完工作后添加修改的文件到仓库暂存区</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<p>然后提交到仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;wrote a readme file&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="4、查看库当前的状态，看看工作区情况"><a href="#4、查看库当前的状态，看看工作区情况" class="headerlink" title="4、查看库当前的状态，看看工作区情况"></a>4、查看库当前的状态，看看工作区情况</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   readme.txt</span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="5-记不清上次怎么修改的，所以，需要用git-diff这个命令看-顾名思义就是查看difference"><a href="#5-记不清上次怎么修改的，所以，需要用git-diff这个命令看-顾名思义就是查看difference" class="headerlink" title="5.记不清上次怎么修改的，所以，需要用git diff这个命令看 顾名思义就是查看difference"></a>5.记不清上次怎么修改的，所以，需要用git diff这个命令看 顾名思义就是查看difference</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff readme.txt</span><br></pre></td></tr></table></figure>
<h4 id="6、版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git-log命令查看："><a href="#6、版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git-log命令查看：" class="headerlink" title="6、版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看："></a>6、版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure>
<h4 id="7、版本回退"><a href="#7、版本回退" class="headerlink" title="7、版本回退"></a>7、版本回退</h4><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$ git reset --hard HEAD^</code></td>
<td align="center">退回到上一个版本</td>
</tr>
<tr>
<td align="center"><code>$ git reset --hard HEAD^^</code></td>
<td align="center">回到上上一个版本</td>
</tr>
<tr>
<td align="center">………</td>
<td align="center">……</td>
</tr>
</tbody></table>
<h4 id="8、-git-reflog用来记录你的每一次命令"><a href="#8、-git-reflog用来记录你的每一次命令" class="headerlink" title="8、 git reflog用来记录你的每一次命令"></a>8、 <code>git reflog</code>用来记录你的每一次命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">版本号</th>
<th align="center">head</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">86a9b0d</td>
<td align="center">(HEAD -&gt; master) HEAD@{0}:</td>
<td align="center">commit: 添加一行(当前head的指向)</td>
</tr>
<tr>
<td align="center">66853e9</td>
<td align="center">HEAD@{1}:</td>
<td align="center">commit: dsfds</td>
</tr>
<tr>
<td align="center">5c159eb</td>
<td align="center">HEAD@{2}:</td>
<td align="center">reset: moving to 5c159eb</td>
</tr>
<tr>
<td align="center">1db339d</td>
<td align="center">HEAD@{3}:</td>
<td align="center">reset: moving to 1db339d</td>
</tr>
<tr>
<td align="center">5c159eb</td>
<td align="center">HEAD@{4}:</td>
<td align="center">reset: moving to file</td>
</tr>
</tbody></table>
<p>回退到指定版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 5c159eb</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Git  log</th>
<th align="center">Git  reflog</th>
</tr>
</thead>
<tbody><tr>
<td align="center">显示所有提交过的版本信息</td>
<td align="center">可以查看所有分支的所有操作记录</td>
</tr>
</tbody></table>
<h4 id="9、用git-diff-HEAD-readme-txt命令可以查看工作区和版本库里面最新版本的区别"><a href="#9、用git-diff-HEAD-readme-txt命令可以查看工作区和版本库里面最新版本的区别" class="headerlink" title="9、用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别"></a>9、用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别</h4><h4 id="10、git-checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。"><a href="#10、git-checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。" class="headerlink" title="10、git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。"></a>10、<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Git checkout -- test.txt     ( 将版本库中的文件替换到工作区)</span><br></pre></td></tr></table></figure>
<h4 id="11、远程仓库"><a href="#11、远程仓库" class="headerlink" title="11、远程仓库"></a>11、远程仓库</h4><h5 id="1-创建SSH-Key。"><a href="#1-创建SSH-Key。" class="headerlink" title="1. 创建SSH Key。"></a>1. 创建SSH Key。</h5><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-登录GitHub-添加-id-rsa-pub到-sshkey"><a href="#2-登录GitHub-添加-id-rsa-pub到-sshkey" class="headerlink" title="2. 登录GitHub 添加 id_rsa.pub到 sshkey"></a>2. 登录GitHub 添加 id_rsa.pub到 sshkey</h5><h5 id="3-新建-leargit-仓库"><a href="#3-新建-leargit-仓库" class="headerlink" title="3. 新建 leargit 仓库"></a>3. 新建 leargit 仓库</h5><h5 id="4-关联远程库与本地库"><a href="#4-关联远程库与本地库" class="headerlink" title="4. 关联远程库与本地库"></a>4. 关联远程库与本地库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:540760029/leargit.git</span><br></pre></td></tr></table></figure>

<h5 id="5-把本地库推送到远程库"><a href="#5-把本地库推送到远程库" class="headerlink" title="5.  把本地库推送到远程库"></a>5.  把本地库推送到远程库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令<br>之后直接使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>把本地master分支的最新修改推送至GitHub</p>
<p><strong>指定分支</strong>推送到<em>指定分支</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin <span class="built_in">source</span>:<span class="built_in">source</span></span><br></pre></td></tr></table></figure>


<h5 id="6-从远程仓库克隆"><a href="#6-从远程仓库克隆" class="headerlink" title="6. 从远程仓库克隆"></a>6. 从远程仓库克隆</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:540760029/leargit.git</span><br></pre></td></tr></table></figure>
<h4 id="12、分支与合并"><a href="#12、分支与合并" class="headerlink" title="12、分支与合并"></a>12、分支与合并</h4><h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><p>创建<code>dev</code> 分支然后切换到<code>dev</code> 分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令</p>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure>
<p>新版本支持</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure>
<p>创建并切换分支</p>
<h5 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure>
<h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure>
<h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure>
<h4 id="13、-修复bug-保存现场与恢复"><a href="#13、-修复bug-保存现场与恢复" class="headerlink" title="13、 修复bug 保存现场与恢复"></a>13、 修复bug 保存现场与恢复</h4><p><code>git stash </code> 将修改的地方保存到隐秘的地方。</p>
<p>切换分支 修改bug,</p>
<p>修改完之后，分支切回来 </p>
<p>将bug在本分支重放：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick  9726d19</span><br></pre></td></tr></table></figure>
<p>查询隐秘地方保存的东西：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Git stash list</span><br></pre></td></tr></table></figure>
<p>回复现场</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br><span class="line">或者</span><br><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>继续工作 keeping!!!</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/09/11/markdown/</url>
    <content><![CDATA[<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>分为六个级别</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br><span class="line">~~删除线~~</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong><br><del>删除线</del><br><u>带下划线</u></p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> <span class="emphasis">* *</span></span></span><br><span class="line"><span class="strong">**</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">- - -</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">----------</span></span></span><br></pre></td></tr></table></figure>

<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">创建脚注格式类似这样 [^1]。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">菜鸟教程 -- 学的不仅是技术，更是梦想！！！</span></span><br></pre></td></tr></table></figure>

<p>创建脚注格式类似这样 [^1]。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>无序列表使用星号(*<strong>**)、加号(</strong>+<strong>)或是减号(</strong>-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">*</span> 第二项</span><br><span class="line"><span class="bullet">*</span> 第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">+</span> 第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 第一项</span><br><span class="line"><span class="bullet">-</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br></pre></td></tr></table></figure>

<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表使用数字并加上 <strong>.</strong> 号来表示，如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">3.</span> 第三项</span><br></pre></td></tr></table></figure>



<h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块引用</span></span><br><span class="line"><span class="quote">&gt; 菜鸟教程</span></span><br><span class="line"><span class="quote">&gt; 学的不仅是技术更是梦想</span></span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（**`**），例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`printf()`</span> 函数</span><br></pre></td></tr></table></figure>

<p>你也可以用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```javascript</span></span><br><span class="line"><span class="code">$(document).ready(function () &#123;</span></span><br><span class="line"><span class="code">    alert(&#x27;***&#x27;);</span></span><br><span class="line"><span class="code">&#125;);</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;***&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接使用方法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>

<p><a href="www.baidu.com">百度</a></p>
<p>&lt;<a href="http://www.baidu.com&gt;/">www.baidu.com&gt;</a></p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Markdown 图片语法格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址</span>)</span><br></pre></td></tr></table></figure>
<img src="http://lixiaofan.info/typora/siberian-husky-5780631_640.jpg" alt="某某图片" style="zoom:50%;">

<p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://lixiaofan.info/typora/siberian-husky-5780631_640.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;某某图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</p>
<p>语法格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>

<p>对齐方式</p>
<p><strong>我们可以设置表格的对齐方式：</strong></p>
<ul>
<li><strong>-:</strong> 设置内容和标题栏居右对齐。</li>
<li><strong>:-</strong> 设置内容和标题栏居左对齐。</li>
<li><strong>:-:</strong> 设置内容和标题栏居中对齐。</li>
</ul>
<p>实例如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>

<h3 id="支持的HTML-元素"><a href="#支持的HTML-元素" class="headerlink" title="支持的HTML 元素"></a>支持的HTML 元素</h3><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，</p>
<p>如：</p>
<ol>
<li><p>使用windows 神奇组合三键  <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Del</kbd> </p>
<p> <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; </code>+<code>&lt;kbd&gt;Alt&lt;/kbd&gt;</code>+<code>&lt;kbd&gt;Del&lt;/kbd&gt;</code></p>
</li>
<li><p>下标 H<sub>2</sub>O</p>
<p> <code>H&lt;sub&gt;2&lt;/sub&gt;O</code></p>
</li>
<li><p>上标  爆米<sup>TM</sup></p>
<p> <code>爆米&lt;sup&gt;TM&lt;/sup&gt;</code></p>
</li>
</ol>
<p>[^1]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p>
]]></content>
      <categories>
        <category>markdown语法</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2020/11/30/nginx/</url>
    <content><![CDATA[<blockquote>
<p>Linux版本： CentOS7 64位</p>
</blockquote>
<h2 id="nginx-安装"><a href="#nginx-安装" class="headerlink" title="nginx 安装"></a>nginx 安装</h2><p><strong>在安装nginx前首先要确认系统中安装了gcc、pcre-devel、zlib-devel、openssl-devel。</strong>安装的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>
<p>nginx 下载地址：<a href="http://nginx.org/download">http://nginx.org/download</a><br>下载：“nginx-1.9.9.tar.gz” 移动到/usr/local/ 下。</p>
<p><img src="https://pic.downk.cc/item/5fc47bd7d590d4788a1b5f6b.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 解压</span></span><br><span class="line">tar -zxvf nginx-1.9.9.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">##进入nginx 目录：</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.9.9</span><br><span class="line"></span><br><span class="line"><span class="comment">##配置</span></span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## make</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注解：源码的安装一般有3个步骤组成：配置(configure)、编译(make)、安装(makeinstall)。 <code>Configure</code>是一个可执行脚本，它有很多选项，在待安装的源码路径下使用命令<code>./configure -–help</code>输出详细的选项列表。其中<code>--prefix</code>选项是配置安装的路径，如果不配置该选项，安装后可执行文件默认放在<code>/usr/local/bin</code>，库文件默认放在<code>/usr/local/lib</code>，配置文件默认放在<code>/usr/local/etc</code>，其它的资源文件放在<code>/usr/local/share</code>，比较凌乱。如果配置–prefix，如：<code>./configure --prefix=/usr/local/nginx</code><br>可以把所有资源文件放在<code>/usr/local/nginx</code>的路径中，不会杂乱。<br>用了—prefix选项的另一个好处是卸载软件或移植软件。当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统）。<br><img src="https://pic.downk.cc/item/5fc47e54d590d4788a1c8ebf.jpg"><br><img src="https://pic.downk.cc/item/5fc47fd8d590d4788a1d5f9a.jpg"></p>
</blockquote>
<h3 id="测试是否安装成功："><a href="#测试是否安装成功：" class="headerlink" title="测试是否安装成功："></a>测试是否安装成功：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## cd 到安装目录 /usr/local/nginx</span></span><br><span class="line">./sbin/nginx -t</span><br></pre></td></tr></table></figure>
<p>安装成功的显示：<br><img src="https://pic.downk.cc/item/5fc48080d590d4788a1dac6b.jpg"></p>
<h3 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx:"></a>启动nginx:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure>
<p>在浏览器输入ip 地址就可以看到结果了</p>
<h3 id="修改默认访问地址："><a href="#修改默认访问地址：" class="headerlink" title="修改默认访问地址："></a>修改默认访问地址：</h3><p><img src="https://pic.downk.cc/item/5fc485c8d590d4788a1fd7ae.jpg"><br><img src="https://pic.downk.cc/item/5fc4864bd590d4788a200ff2.jpg"><br><img src="https://pic.downk.cc/item/5fc48700d590d4788a205b06.jpg"></p>
<p>根据访问路径在相应的位置创建好的文件夹:放入测试文件<br><img src="https://pic.downk.cc/item/5fc48741d590d4788a206e89.jpg"></p>
<h3 id="重启nginx-服务："><a href="#重启nginx-服务：" class="headerlink" title="重启nginx 服务："></a>重启nginx 服务：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 进入到 /usr/local/nginx/sbin</span></span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#查看nginx 的版本：</span></span><br><span class="line">./nginx -v</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭nginx：</span></span><br><span class="line">./nginx -s stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动nginx:</span></span><br><span class="line">./nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看nginx的进程：</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启nginx:</span></span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote>
<p>/usr/local/nginx/conf/nginx.conf</p>
</blockquote>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><h4 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h4><p>从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令。例如：<br><code>worker_processes 1</code> 支持的并发处理量</p>
<h4 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h4><p>影响Nginx服务器与用户的网络链接，例如：<br><code>worker_connections 1024</code> 支持最大链接数</p>
<h4 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h4><h3 id="配置实例："><a href="#配置实例：" class="headerlink" title="配置实例："></a>配置实例：</h3><ol>
<li>反向代理</li>
</ol>
<p><code> prooxy_pass http://127.0.0.1:8080</code><br>访问ip 跳转到8080端口</p>
<ul>
<li>根据路径跳转到不同的端口 </li>
</ul>
<p>再写一个server<br><img src="https://pic.downk.cc/item/5fc8afea394ac5237847dd77.jpg"></p>
<p><img src="https://pic.downk.cc/item/5fc8b156394ac5237849641b.jpg"></p>
<ol start="2">
<li>负载均衡</li>
</ol>
<p><img src="https://pic.downk.cc/item/5fc8b37a394ac523784a49d0.jpg"> </p>
<p><strong>分配策略</strong></p>
<ul>
<li>轮询策略 ：每个请求安时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。默认策略</li>
<li>weight : 权重，默认为1，权重越高被分配的客户端越多</li>
<li>ip_hash : 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器</li>
<li>fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的服务优先分配</li>
</ul>
<h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><blockquote>
<p>动静分离：动态请求 和 静态请求 的两种请求。 两种方式 分开发布， 合并发布，用nginx分开</p>
</blockquote>
<p>通过location 指定不同的后缀名实现不同的请求转发。通过expires 参数设置，可以<br><img src="https://pic.downk.cc/item/5fc8ccf9394ac52378583cda.jpg"><br><img src="https://pic.downk.cc/item/5fc8ce73394ac52378594734.jpg"></p>
<p><code>autoindex on;</code> 列出文件夹下的列表</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p><img src="https://pic.downk.cc/item/5fc8d0ad394ac523785b381e.jpg"></p>
<p>需要两台ngnix、keepalived、 虚拟ip.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 安装keepalived</span></span><br><span class="line">yum install keepalived -y</span><br><span class="line"></span><br><span class="line"><span class="comment">##启动keeplived</span></span><br><span class="line">systemctl start keepalived.service</span><br><span class="line"></span><br><span class="line"><span class="comment">##停止keeplived </span></span><br><span class="line">systemctl stop keeplived.service</span><br><span class="line"></span><br><span class="line"><span class="comment">##安装目录配置文件在：/etc/keepalived/keepalived.conf</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置高可用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 网卡查看：</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看主机与配置</span></span><br><span class="line">vi /etc/hosts</span><br><span class="line"><span class="comment">## 添加：127.0.0.1  LVS_DEVEL   （随便写）</span></span><br></pre></td></tr></table></figure>

<p>keepalived.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 全局配置</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">	notification_email &#123;</span><br><span class="line">		acassen@firewall.loc</span><br><span class="line">		failover@firewall.loc</span><br><span class="line">		sysadmin@firewall.loc</span><br><span class="line">	&#125;</span><br><span class="line">	notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">	smtp_server 192.168.17.129</span><br><span class="line">	smtp_connect_timeout 30</span><br><span class="line">	router_id LVS_DEVEL  <span class="comment">## 访问的主机</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">## 脚本配置</span></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">	script <span class="string">&quot;/usr/local/src/nginx_check.sh&quot;</span></span><br><span class="line">	interval 2 <span class="comment">#（检测脚本执行的间隔）</span></span><br><span class="line">	weight 2 <span class="comment"># 权重 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">##虚拟ip 配置</span></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">	state BACKUP <span class="comment"># 备份服务器上将 MASTER 改为 BACKUP</span></span><br><span class="line">	interface ens33 <span class="comment"># 网卡</span></span><br><span class="line">	virtual_router_id 51 <span class="comment"># 主、备机的 virtual_router_id 必须相同</span></span><br><span class="line">	priority 90 <span class="comment"># 主、备机取不同的优先级，主机值较大，备份机值较小</span></span><br><span class="line">	advert_int 1 <span class="comment"># 每隔1秒发送一个心跳</span></span><br><span class="line">	authentication &#123;</span><br><span class="line">		auth_type PASS</span><br><span class="line">		auth_pass 1111</span><br><span class="line">	&#125;</span><br><span class="line">	virtual_ipaddress &#123;</span><br><span class="line">		192.168.17.50 <span class="comment"># VRRP H 虚拟地址</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> /usr/local/src 添加检测脚本：nginx_check.sh<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#!/bin/bash</span></span><br><span class="line">A=`ps -C nginx – no-header |<span class="built_in">wc</span> -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$A</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">	/usr/local/nginx/sbin/nginx</span><br><span class="line">	<span class="built_in">sleep</span> 2</span><br><span class="line">	<span class="keyword">if</span> [ `ps -C nginx --no-header |<span class="built_in">wc</span> -l` -eq 0 ];<span class="keyword">then</span></span><br><span class="line">		killall keepalived</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="nginx-工作原理"><a href="#nginx-工作原理" class="headerlink" title="nginx 工作原理"></a>nginx 工作原理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看nginx 进程</span></span><br><span class="line">ps -ef |grep nginx</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.downk.cc/item/5fc8dca2394ac523786533b8.jpg"></p>
<p><img src="https://pic.downk.cc/item/5fc8dc74394ac5237865226f.jpg"><br><img src="https://pic.downk.cc/item/5fc8dce7394ac52378654864.jpg"></p>
<ul>
<li><p>首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。</p>
</li>
<li><p>其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断， master 进程则很快启动新的worker进程。</p>
</li>
<li><p>当然， worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险</p>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/xxoome/p/5866475.html">https://www.cnblogs.com/xxoome/p/5866475.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabbitmq</title>
    <url>/2022/10/09/rabbitmq/</url>
    <content><![CDATA[<h2 id="下载RabbitMQ"><a href="#下载RabbitMQ" class="headerlink" title="下载RabbitMQ"></a>下载RabbitMQ</h2><blockquote>
<p>下载地址：<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p>
</blockquote>
<h2 id="下载Erlang"><a href="#下载Erlang" class="headerlink" title="下载Erlang"></a>下载Erlang</h2><blockquote>
<p>Erlang和RabbitMQ版本对照：<a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a><br>下载地址：<a href="https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-23.2.7-2.el7.x86_64.rpm">https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-23.2.7-2.el7.x86_64.rpm</a></p>
</blockquote>
<h2 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh erlang-23.2.7-2.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>查看版本号：<code>erl -v</code></p>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><ol>
<li>安装必要依赖组件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure></li>
<li>安装socat<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y socat</span><br></pre></td></tr></table></figure></li>
<li>rmp 安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh rabbitmq-server-3.8.35-1.el8.noarch.rpm</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol>
<li>启动rabbitmq:<code>systemctl start rabbitmq-server</code> </li>
<li>查看状态： <code>systemctl status rabbitmq-server</code></li>
<li>开机自启动：<code>systemctl enable rabbitmq-server</code></li>
<li>关闭rabbitmq:<code>systemctl stop rabbitmq-server</code> </li>
<li>重启rabbitmq:<code>systemctl restart rabbitmq-server</code> </li>
</ol>
<h2 id="管理界面插件"><a href="#管理界面插件" class="headerlink" title="管理界面插件"></a>管理界面插件</h2><p><code>rabbitmq-plugins enable rabbitmq_management</code><br>rabbitmq有一个默认的账号密码guest，但该情况仅限于本机localhost进行访问，所以需要添加一个远程登录的用户</p>
<ol>
<li>添加用户：<code>rabbitmqctl add_user 用户名 密码</code></li>
<li>设置用户角色,分配操作权限：<code>rabbitmqctl set_user_tags 用户名 角色</code></li>
<li>为用户添加资源权限(授予访问虚拟机根节点的所有权限)：<code>rabbitmqctl set_permissions -p / 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></li>
<li>修改密码：<code>rabbitmqctl change_ password 用户名 新密码</code></li>
<li>删除用户：<code>rabbitmqctl delete_user 用户名</code></li>
<li>查看用户清单: <code>rabbitmqctl list_users</code><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3></li>
<li><code>administrator</code> :可以登录控制台、查看所有信息、并对rabbitmq进行管理</li>
<li><code>monToring</code>:监控者；登录控制台，查看所有信息</li>
<li><code>policymaker</code>:策略制定者；登录控制台指定策略</li>
<li><code>managment</code>:普通管理员；登录控制</li>
</ol>
]]></content>
      <tags>
        <tag>rabbitmq安装</tag>
      </tags>
  </entry>
</search>
